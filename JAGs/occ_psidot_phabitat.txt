
  model {

    # Priors
    
    b0.psi ~ dnorm( 0, 0.001 )T(-10,10) #uninformative
    b00.p ~ dnorm( 0, 0.001 )T(-10, 10) 
    b01.p ~ dnorm( 0, 0.001 )T(-10, 10) 
    b02.p ~ dnorm( 0, 0.001 )T(-10, 10) 
    b03.p ~ dnorm( 0, 0.001 )T(-10, 10) 
    b04.p ~ dnorm( 0, 0.001 )T(-10, 10) 
    b05.p ~ dnorm( 0, 0.001 )T(-10, 10) 
   
    
    logit(mean.psi) <- b0.psi        #outputting the backtransformed mean.psi
    
    logit(mean.p.Flatwoods) <- b00.p   #outputting the backtransformed p
    logit(mean.p.GrassPrairie) <-  b01.p
    logit(mean.p.Oak) <-  b02.p
    logit(mean.p.Plantations) <-  b03.p
    logit(mean.p.Scrub) <-  b04.p
    logit(mean.p.SwampMarsh) <-  b05.p
   
    
    
    for( i in 1:nSite ){
      logit( psi[i] ) <- b0.psi       
      for( t in 1:nocc ){
          logit( p[i,t] ) <- b00.p*Flatwoods[i]
          + b01.p*GrassPrairie[i] + b02.p*Oak[i] + b03.p*Plantations[i] + b04.p*Scrub[i]
          + b05.p*SwampMarsh[i] 
      }
    }
    

    # Likelihood
    
    for( i in 1:nSite ){
      # process model - occupancy
      z[i] ~ dbern( psi[i] )         #creating a vector for what sites 
    
      # observation model  - linking occupancy and detection
      for( t in 1:nocc ){
        y[i,t] ~ dbern( z[i]*p[i,t] )  
      }
    }
    
    
    # Derived parameters
    # number of sites occupied
    N <- sum(z[]) 
  
  }